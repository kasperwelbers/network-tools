```{r, include=FALSE}
opts_chunk$set(fig.path = "figures_author_network/")
```

Author networks
==========================

An author network is a network of authors of documents/texts. Common author networks are based on co-authorship (which author collaborated) or conversations (who communicated with whom). 

In this howto we show several functions to create author networks, based on common ways in which author information of documents is stored.


```{r, message=F}
library(networktools)
```

Co-author networks
=====================

For the co-author network, we use scientific articles in 10 communication sciences journals from Web of Science, with 'social network' as a topic, from 2001 till 2009.

```{r, message=F}
load('../demo/abstracts_socialnet.rdata')

head(meta)
```

To create co-author networks, we only need to know which authors (co-)authored which documents. A good way to represent this information is a data.frame in which one column represents document_id's and one column represents authors, or a matrix in which rows are documents and columns are authors. 

However, if author information is stored as meta data of documents, multiple authors are often stored within the same author field/column (as is the case in our example). As the R language is not very intuitive for reorganizing this data (without botheringly inefficient loops) we offer a function for this purpose.

The strsplit function is essentially the `strsplit()` function (base function), but returns the splitten parts of the strings (substrings) as rows. 

```{r, message=F}
coauthors = strsplit.to.rows(x = meta$authors, id=meta$id, split_by=';')
head(coauthors)
```

Now we have the data in the right format, we can use the `author.coincidence.graph` function to make the graph. The name of the function refers to how the graph is created: It counts how many times authors co-incide as authors of the same documents.

The first argument of the function is a vector with the id's for documents in which an author authored. The second argument is the (unique) author name/id. We can directly use the output from strsplit.to.rows. 

```{r, message=F}
g = author.coincidence.graph(coauthors$id, coauthors$substring) # In how many documents did author.X and author.Y co-author?
```

The output is a graph in the igraph format. 

```{r, message=F}
plot(g, vertex.size=V(g)$n.domain*2, vertex.label='', edge.color='black') 
```

Conversation networks
=====================

For the conversation network, we use speech acts in Dutch parliamentary proceedings by two parties (VVD and CDA) from 2003 till 2005 (samples of 100 proceedings per year). 

```{r, message=F}
load('../demo/parliamentary_proceedings.rdata')
meta$author = paste(meta$name, meta$party)
head(meta)
```

The column `meeting` represents the meetings in which speech acts are performed. `speech_act` represents the order in which people have spoken. `author` represents the unique participants in the discussion. These are the main variables to create the network. Note that on the internet many interactions fit this format, such as discussion boards (thread-postnr-author).

We present three functions to make a conversation network. The first is the same way as for the co-author network. The order in which authors have spoken is then ignored, and ties represent only how often authors participated in the same conversation. Because we are now also interested in how many times authors participated within a meeting, we can also use a different measure (e.g., cosine) to calculate the coincidence.

```{r, message=F}
g = author.coincidence.graph(meta$meeting, meta$author, 'cosine') # To what extent did politicians participate in the same conversations?
plot(g, vertex.size=sqrt(V(g)$n.domain), vertex.label='') 
```

The second way to make the conversation network does take order into account. With `previous.authors.graph` we can draw ties between authors who communicated within a given distance of speech acts. The `lookback` argument indicates the max distance between the speech act of an author and the previous authors. For example, if lookback is 1, ties are drawn for every time an author directly responded to another author. Note that this also allows a direction to be given to ties/edges (from author to previous author(s) or the other way around). 

```{r, message=F}
g = previous.authors.graph(meta$meeting, meta$author, meta$speech_act, lookback=1, direction='directed.up') 
plot(g, vertex.size=sqrt(V(g)$n.domain), vertex.label='', edge.width=sqrt(E(g)$width), edge.arrow.size=sqrt(E(g)$width)/4) 
```

The third way to make the conversation network is by only drawing ties between the first author and all next authors in the conversation. This works similarly to `previous.authors.graph`, but requires no `lookback` argument.

```{r, message=F}
g = first.author.graph(meta$meeting, meta$author, meta$speech_act,  direction='directed.up') 
plot(g, vertex.size=sqrt(V(g)$n.domain), vertex.label='', edge.width=sqrt(E(g)$width), edge.arrow.size=sqrt(E(g)$width)/4) 
```
